import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import ArticlesPage from './page';
import '@testing-library/jest-dom';

// Mock fetch globally
global.fetch = jest.fn() as jest.Mock;

const mockArticles = [
  {
    _id: '1',
    title: 'Test Article 1',
    author: 'Author 1',
    published_date: '2020',
    description: 'Description 1',
    publisher: 'Publisher 1',
    status: 'accepted',
    journal: 'Journal 1',
    rating: 4,
    moderatedBy: 'Moderator 1',
    practice: ['TDD', 'CI'],
    claim: 'Claim 1, Claim 2',
  },
  {
    _id: '2',
    title: 'Test Article 2',
    author: 'Author 2',
    published_date: '2021',
    description: 'Description 2',
    publisher: 'Publisher 2',
    status: 'pending',
    journal: 'Journal 2',
    rating: 3,
    moderatedBy: 'Moderator 2',
    practice: ['CI'],
    claim: 'Claim 2, Claim 3',
  },
];

describe('ArticlesPage', () => {
  beforeEach(() => {
    // Clear localStorage and reset mocks
    localStorage.clear();
    (global.fetch as jest.Mock).mockClear();
    (global.fetch as jest.Mock).mockResolvedValueOnce({
      ok: true,
      json: async () => mockArticles,
    });
  });

  test('renders loading state initially', async () => {
    render(<ArticlesPage />);
    expect(screen.getByText('Loading articles...')).toBeInTheDocument();
    await waitFor(() => {});
  });

  test('displays articles after loading', async () => {
    render(<ArticlesPage />);
    await waitFor(() => {
      expect(screen.getByText('Test Article 1')).toBeInTheDocument();
      expect(screen.getByText('Test Article 2')).toBeInTheDocument();
    });
  });

  test('column selector shows/hides columns', async () => {
    render(<ArticlesPage />);
    await waitFor(() => screen.getByText('Test Article 1'));

    // Open column selector
    fireEvent.click(screen.getByText('Columns'));
    
    // Unselect Practice column
    fireEvent.click(screen.getByLabelText('Practice'));
    
    // Verify Practice column is hidden
    expect(screen.queryByText('Practice')).not.toBeInTheDocument();
    expect(screen.queryByText('TDD, CI')).not.toBeInTheDocument();
    
    // Re-select Practice column
    fireEvent.click(screen.getByText('Columns'));
    fireEvent.click(screen.getByLabelText('Practice'));
    
    // Verify Practice column reappears
    expect(screen.getByText('Practice')).toBeInTheDocument();
    expect(screen.getByText('TDD, CI')).toBeInTheDocument();
  });

  test('column preferences persist in localStorage', async () => {
    render(<ArticlesPage />);
    await waitFor(() => screen.getByText('Test Article 1'));

    // Hide Rating column
    fireEvent.click(screen.getByText('Columns'));
    fireEvent.click(screen.getByLabelText('Rating'));
    
    // Verify localStorage updated
    const savedPrefs = JSON.parse(localStorage.getItem('columnVisibility') || {});
    expect(savedPrefs.rating).toBe(false);
    
    // Refresh component
    render(<ArticlesPage />);
    await waitFor(() => {});
    
    // Verify Rating column remains hidden
    expect(screen.queryByText('Rating')).not.toBeInTheDocument();
  });

  test('practice and claims filtering interaction', async () => {
    render(<ArticlesPage />);
    await waitFor(() => screen.getByText('Test Article 1'));

    // Open practice dropdown and select CI
    const practiceSelect = screen.getByLabelText('Practice filter');
    fireEvent.change(practiceSelect, { target: { value: 'CI' } });
    
    // Verify claims dropdown is enabled and has correct options
    const claimsSelect = screen.getByLabelText('Claims filter');
    expect(claimsSelect).toBeEnabled();
    
    // Open claims dropdown
    fireEvent.mouseDown(claimsSelect);
    
    // Verify claims options
    await waitFor(() => {
      expect(screen.getByText('Claim 1')).toBeInTheDocument();
      expect(screen.getByText('Claim 2')).toBeInTheDocument();
      expect(screen.getByText('Claim 3')).toBeInTheDocument();
    });
    
    // Select Claim 2
    fireEvent.click(screen.getByText('Claim 2'));
    
    // Verify filtering works
    expect(screen.getByText('Test Article 1')).toBeInTheDocument();
    expect(screen.getByText('Test Article 2')).toBeInTheDocument();
    
    // Select Claim 3
    fireEvent.change(claimsSelect, { target: { value: 'Claim 3' } });
    
    // Verify only article with Claim 3 is shown
    expect(screen.queryByText('Test Article 1')).not.toBeInTheDocument();
    expect(screen.getByText('Test Article 2')).toBeInTheDocument();
  });

  test('claims dropdown disabled when no practice selected', async () => {
    render(<ArticlesPage />);
    await waitFor(() => screen.getByText('Test Article 1'));
    
    const claimsSelect = screen.getByLabelText('Claims filter');
    expect(claimsSelect).toBeDisabled();
    expect(claimsSelect).toHaveTextContent('Select a practice first');
    
    // Select a practice
    const practiceSelect = screen.getByLabelText('Practice filter');
    fireEvent.change(practiceSelect, { target: { value: 'TDD' } });
    
    // Verify claims dropdown enabled
    expect(claimsSelect).toBeEnabled();
    expect(claimsSelect).toHaveTextContent('All Claims');
  });

  test('claims reset when practice changes', async () => {
    render(<ArticlesPage />);
    await waitFor(() => screen.getByText('Test Article 1'));
    
    // Select CI practice
    const practiceSelect = screen.getByLabelText('Practice filter');
    fireEvent.change(practiceSelect, { target: { value: 'CI' } });
    
    // Select Claim 2
    const claimsSelect = screen.getByLabelText('Claims filter');
    fireEvent.change(claimsSelect, { target: { value: 'Claim 2' } });
    
    // Change practice to TDD
    fireEvent.change(practiceSelect, { target: { value: 'TDD' } });
    
    // Verify claims reset to "All Claims"
    expect(claimsSelect).toHaveValue('All');
  });

  test('no claims message appears when practice has no claims', async () => {
    // Update mock data for this test
    const noClaimArticles = [...mockArticles];
    noClaimArticles[0].claim = '';
    noClaimArticles[1].claim = '';
    
    (global.fetch as jest.Mock).mockResolvedValueOnce({
      ok: true,
      json: async () => noClaimArticles,
    });
    
    render(<ArticlesPage />);
    await waitFor(() => screen.getByText('Test Article 1'));
    
    // Select CI practice
    const practiceSelect = screen.getByLabelText('Practice filter');
    fireEvent.change(practiceSelect, { target: { value: 'CI' } });
    
    // Verify claims dropdown message
    const claimsSelect = screen.getByLabelText('Claims filter');
    expect(claimsSelect).toBeDisabled();
    expect(claimsSelect).toHaveTextContent('No claims for this practice');
  });
});
